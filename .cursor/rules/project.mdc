---
alwaysApply: true
---

You are an expert in TypeScript, Vue 3, Vite, TanStack Vue Query, Pinia, Vue Router, Axios, Orval, Vitest, and Tailwind CSS v4.

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use Composition API with `<script setup lang="ts">` exclusively; never use Options API.
- Prefer modularization into composables and utilities over duplicating logic in views.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`, `historyLoading`).
- Structure files: exported component → composables/imports → reactive state → computed → functions → template.
- Keep views thin: extract complex logic into composables under `src/composables/`.

## Naming Conventions

- Directories: lowercase with dashes (e.g., `test-utils/`, `auth-wizard/`).
- Components: PascalCase (e.g., `ChatMessage.vue`, `BottomNav.vue`).
- Composables: camelCase prefixed with `use` (e.g., `useChat.ts`, `useMonthlyResume.ts`).
- Utilities: camelCase, grouped by domain (e.g., `categoryHelpers.ts`, `dateHelpers.ts`).
- Constants: UPPER_SNAKE_CASE in `src/constants.ts` (e.g., `MONTH_NAMES`).
- Follow Clean Code: names must be descriptive, no abbreviations (avoid `fmt`, `pct`, `cb`, `res`).

## TypeScript

- TypeScript in all files; prefer `type` over `interface`.
- Avoid `enum`; use `const` objects with `as const` instead.
- Export types alongside the logic they belong to (e.g., `export type ChatMessage` in `useChat.ts`).
- Never use `any`; use `unknown` and narrow with type guards.

## Project Structure

```
src/
├── api/
│   └── generated/          # ⚠️ Never edit manually — generated by Orval
│       ├── chat/chat.ts
│       ├── categories/
│       ├── transactions/
│       ├── settings/
│       ├── users/
│       └── táLisoAPI.schemas.ts
├── assets/main.css          # Tailwind v4 entry: @import 'tailwindcss'
├── components/              # Reusable UI components
├── composables/             # Reusable logic hooks
├── constants.ts             # Global constants (MONTH_NAMES, etc.)
├── router/index.ts          # Vue Router config + auth guard
├── services/api.ts          # Axios instance + Orval mutator
├── stores/                  # Pinia stores
├── test-utils/              # mountWithRouter, mockData factories
├── utils/                   # Pure functions (categoryHelpers, dateHelpers)
└── views/                   # One .vue file per route
```

## API Layer (Orval + TanStack Vue Query)

- All API hooks live in `src/api/generated/` — run `npm run gen:api` to regenerate.
- Never write raw `axios` calls in components or composables; always use generated hooks or extend via composables.
- Use `useQueryClient()` + `queryClient.invalidateQueries()` to keep caches in sync after mutations.
- Wrap multiple related API hooks in a single composable (e.g., `useChat` encapsulates history, send, toast alerts and scroll).
- Query keys: always use the generated `get*QueryKey()` functions for invalidation.

```ts
// Good — wrap in composable
export function useChat() {
  const { data: history, isLoading: historyLoading } = useGetHistoryApiChatGet()
  const chat = useChatApiChatPost({ mutation: { onSuccess: () => { ... } } })
  return { history, historyLoading, chat }
}

// Bad — raw hook usage scattered in view
const { data } = useGetHistoryApiChatGet()
```

## State Management (Pinia)

- One store per domain in `src/stores/` (e.g., `toast.ts`, `useAuth.ts`).
- Use `defineStore` with the Composition API style (setup stores).
- Keep stores focused; complex derived state belongs in composables, not stores.

## Routing

- Routes defined in `src/router/index.ts` with `meta.topbar` for DesktopTopbar titles.
- Auth guard via `router.beforeEach` — checks `localStorage.getItem('access_token')`.
- Auth routes (`login`, `token`) bypass the AppShell layout entirely.

## UI and Styling

- Use Tailwind CSS v4 — imported via `@import 'tailwindcss'` in `src/assets/main.css`.
- No `tailwind.config.js` needed; use CSS custom properties for design tokens.
- Mobile-first responsive design; desktop breakpoint is `lg:` (1024px).
- Brand colors (use as inline styles or Tailwind arbitrary values):
  - Primary orange: `#E8500A`
  - Yellow accent: `#F5C518`
  - Background warm: `#F5EDD8`
  - Border: `#E5D9C3`
  - Dark text: `#1A1008`
  - Muted text: `#7A6E5F`
  - Green success: `#1E8C45`
  - Red danger: `#C0252A`
- Layout:
  - Mobile: `BottomNav` (rendered in the view itself)
  - Desktop (`lg+`): `DesktopSidebar` + `DesktopTopbar` via `AppShell.vue`

## Utilities

- **Currency:** always use `formatBRL(value)` from `src/utils/categoryHelpers.ts` — never inline `.toLocaleString('pt-BR', ...)`.
- **Date/time:** use `formatCurrentTime()` and `formatCurrentDate()` from `src/utils/dateHelpers.ts`.
- **Category helpers:** `categoryPercentage`, `categorySpent`, `barColor`, `balanceColor` from `categoryHelpers.ts`.

## Tests (Vitest + @vue/test-utils)

- BDD-style: `Feature → Scenario → it()` naming, AAA (Arrange / Act / Assert) pattern.
- All view tests go in `src/views/__tests__/`.
- Use `mountWithRouter(Component, { route })` from `src/test-utils/mountWithRouter.ts` — it includes Router, Pinia, and VueQueryPlugin.
- Mock API hooks with `vi.mock()` using shared `ref` so state can be reset in `beforeEach`.
- Mock composables entirely when testing views (e.g., `vi.mock('@/composables/useChat', ...)`).
- Use `createCategory()` / `createTransaction()` factories from `src/test-utils/mockData.ts`.

```ts
// Good — mock pattern
const dataRef = ref<CategoryResponse[]>([])
vi.mock('@/api/generated/categories/categories', () => ({
  useListCategoriesApiCategoriesGet: () => ({ data: dataRef, isLoading: ref(false) }),
}))

describe('Feature: Tela Início', () => {
  beforeEach(() => { dataRef.value = [] })

  it('exibe estado vazio quando não há categorias', async () => {
    // Arrange
    dataRef.value = []
    // Act
    const { wrapper } = await mountWithRouter(HomeView, { route: '/' })
    await wrapper.vm.$nextTick()
    // Assert
    expect(wrapper.text()).toContain('Nenhuma categoria ainda.')
  })
})
```

## Composables

- One concern per composable; expose only what the caller needs.
- Reactive DOM side-effects (scroll, event listeners) belong in the composable with `onUnmounted` cleanup.
- Use `watch` + `nextTick` / `requestAnimationFrame` for post-render DOM work (e.g., scroll-to-bottom).

## Componentization

Views and components should stay small and focused. Extract a new component whenever any of these is true:

**Extract when:**
- A block of template exceeds ~80 lines.
- A visual section has a clear, self-contained responsibility (e.g., a card, a list item, a sidebar, a header).
- The same markup structure appears more than once (even with slightly different data).
- A block needs its own local state or event listeners that don't belong to the parent.

**Where components live:**
- `src/components/` — shared across multiple views.
- Co-located inside a view subfolder if used only by that view (e.g., `src/views/chat/ChatMessage.vue`). Only move to `src/components/` if reused elsewhere.

**Naming extracted components:**
- Prefix with the parent context to make origin clear: `ChatMessage.vue`, `ChatTypingIndicator.vue`, `ResumoCategoriasCard.vue`, `HomeBalanceCard.vue`.
- Never use generic names like `Card.vue`, `Item.vue`, `Section.vue` — always qualify with context.

**Props and emits:**
- Prefer passing plain data via props over passing reactive refs or entire store objects.
- Use `defineEmits` for user interactions; do not pass callbacks as props.
- Keep prop types tight — prefer specific types over `object` or `any`.

**Avoid:**
- Views with more than ~150 lines of template.
- Deeply nested `v-if/v-else` chains inside a view — each branch is usually a component.
- Repeating the same Tailwind class groups in sibling elements — extract a component instead of a CSS class.

**Example split:**
```
// Before: ChatView.vue with 4 inline message variants (~90 lines of v-if/v-else)

// After:
src/components/ChatMessage.vue       ← renders the correct variant based on message type
src/views/ChatView.vue               ← <ChatMessage v-for="..." :message="message" />
```

## Key Conventions

- Never edit files under `src/api/generated/` — regenerate with `npm run gen:api`.
- Always use `formatBRL` for currency; never inline locale formatting.
- Component file = one component. Extract sub-parts as separate `.vue` files when the template exceeds ~80 lines or a block would repeat.
- Do not add `console.log` in production code.
- Comments only where intent is non-obvious; do not comment self-evident code.

## Documentation Repository

The project documentation lives in a **separate repository**, one level up from this project. The folder may be named `docs` or `docs-ta-liso-app`:

```
../docs
# or
../docs-ta-liso-app
```

Relevant files:
- `ta-liso-BDD.md` — BDD scenarios for all features (Features, Scenarios, Given/When/Then)
- `ta-liso-FRONTEND-INTEGRATION.md` — API integration guide: generated hooks, composable patterns, schemas, code examples

### Rule: always update the docs when behavior changes

Whenever you implement or change **any behavior** — new feature, changed composable, new API integration pattern, updated component contract, changed route, new utility — you **must** update the relevant doc file and commit it to the docs repo.

```bash
# Edit the relevant doc file, then (adjust path if folder is docs-ta-liso-app):
git -C '../docs' add <file>
git -C '../docs' commit -m "docs: <describe what changed>"
```

Examples of what triggers a doc update:
- New composable or change in what it returns → update `ta-liso-FRONTEND-INTEGRATION.md`
- New route or changed auth behavior → update both docs
- New BDD scenario implemented → check `ta-liso-BDD.md` and mark/add the scenario
- New API endpoint integrated → update integration patterns in `ta-liso-FRONTEND-INTEGRATION.md`
- Changed component API (props, emits) → update relevant section

## Scripts

- `npm run dev` — dev server (http://localhost:5173)
- `npm run build` — production build
- `npm run test:unit` — Vitest
- `npm run lint` — oxlint + eslint (with --fix)
- `npm run format` — prettier
- `npm run type-check` — vue-tsc
- `npm run gen:api` — regenerate API client from OpenAPI spec
